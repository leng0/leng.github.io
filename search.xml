<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[EventLoop]]></title>
    <url>%2F2018%2F09%2F03%2Flayout%2F</url>
    <content type="text"><![CDATA[EventLoop众所周知JShi非阻塞单线程语言，因为在最初JS就是了和浏览器交互而诞生的。如果JS是们多线程语言，我们在多线程处理DOM就可能会发生问题（一个线程中新加节点，另一个线程中删掉节点）。当然我们可以引入读写锁解决这个问题。 JS在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到Task（有多种Task）队列中。一旦执行栈为空，EventLoop就会从Task队列中拿出需要执行的代码并存入执行栈当中执行，所以本质来说JS的异步还是同步的行为。 123456console.log('script start');setTimeout(function()&#123; console.log('setTimeout');&#125;,0);console.log('script end'); 以上代码虽然色图Timeout延时为0，其实还是异步。这是因为HTML5标准规定这个函数第二个参数不得小于4毫秒，不足会自动增加。所以setTimeout还好似会在script end之后打印。 不同的任务源会被分配到不同的Task队列中，任务源可以分为微任务（microtask）和宏任务（macrotask）。在ES6规范中，microtask称作jobs，macrotask称作task。 1234567891011121314console.log('script start');setTimeout(function()&#123; console.log('setTimeout');&#125;,0)new Promise((resolve) =&gt;&#123; console.log('Promise') resolve()&#125;).then(function()&#123; console.log('promise1');&#125;).then(function()&#123; console.log('promise2');&#125;);console.log('script end');//script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout 以上代码虽然setTimeout写在Promise之前，但是Promise执行微任务，色图Timeout属于宏任务。 微任务包括process.nextTick promise Object.observe MutationObserver 宏任务包括script setTimeout setInterval setImmediate I/O UI rendering 很多人有误区认为微任务快于宏任务其实错的。因为宏任务中包括script 浏览器会先执行一个宏任务，接下来会有异步代码的话就先执行微任务。 所以正确的EventLoop顺序是这样的 执行同步代码，这属于宏任务 执行栈为空，查询是否有微任务执行 执行所有微任务 必要的话渲染UI 然后下一轮EventLoop，执行宏任务中异步代码 通过上述的EventLoop顺序可知，如果宏任务中的异步代码有大量的计算且需要操作DOM的话，为了更快的页面响应，我们可以把操作DOM放入微任务中。 Node中的EventLoopNode 中的 Event loop 和浏览器中的不相同。 Node 的 Event loop 分为6个阶段，它们会按照顺序反复运行 图片 timertimer阶段会执行色图Timeout和setInterval 一个timer指定的时间并不是准确的时间，而是在达到这个时间后尽快执行回调，可能会因为系统正在执行别的事务而延迟。 下限的时间有一个范围：[1, 2147483647] ，如果设定的时间不在这个范围，将被设置为1 I/OI/OI阶段会执行除了close时间定时器和setImmediate的回调 idle, prepareidle, prepare 阶段内部实现 pollpoll 阶段很重要，这一阶段中，系统会做两件事情 执行到点的定时器 执行 poll 队列中的事件 并且当 poll 中没有定时器的情况下，会发现以下两件事情 如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制 如果 poll 队列为空，会有两件事发生 如果有 setImmediate 需要执行，poll 阶段会停止并且进入到 check 阶段执行 setImmediate 如果没有 setImmediate 需要执行，会等待回调被加入到队列中并立即执行回调 如果有别的定时器需要被执行，会回到 timer 阶段执行回调 ####check check阶段执行setImmediate close callbacksclose callbacks 阶段执行 close 事件 并且在 Node 中，有些情况下的定时器执行顺序是随机的 12345678910setTimeout(() =&gt; &#123; console.log('setTimeout');&#125;,0);setImmediate(() =&#123; console.log('setImmediate');&#125;)//这里可能会输出色图Timeout setImmediate//可能也会相反的输出，这取决于性能//因为可能进入eventloop之后用了不到1毫秒就会执行setImmediate//否则就会执行setTimeout 当然在这种情况下执行顺序是相同的 1234567891011121314var fs = require('fs')fs.readFile(_filename, ()=&gt; &#123; setTimeout(() =&gt; &#123; console.log('timeout'); &#125;,0); setImmediate(()=&gt; &#123; console.log('immediate'); &#125;);&#125;);//因为readFile的回调在poll中执行//发现有setImmediate所以会立即跳到check阶段执行回调//再去timer阶段执行setTimeout//所以以上输出一定是setImmediate setTimeout 上面介绍的都是macrotask的执行情况microtask会在以上每个阶段完成后立即执行 1234567891011121314151617181920 setTimeout(()=&gt;&#123; console.log('timer1') Promise.resolve().then(function() &#123; console.log('promise1') &#125;)&#125;, 0)setTimeout(()=&gt;&#123; console.log('timer2') Promise.resolve().then(function() &#123; console.log('promise2') &#125;)&#125;, 0)// 以上代码在浏览器和 node 中打印情况是不同的// 浏览器中一定打印 timer1, promise1, timer2, promise2// node 中可能打印 timer1, timer2, promise1, promise2// 也可能打印 timer1, promise1, timer2, promise2 Node 中的 process.nextTick 会先于其他 microtask 执行 123456789101112setTimeout(() =&gt; &#123; console.log("timer1"); Promise.resolve().then(function() &#123; console.log("promise1"); &#125;);&#125;, 0);process.nextTick(() =&gt; &#123; console.log("nextTick");&#125;);// nextTick, timer1, promise1]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域]]></title>
    <url>%2F2018%2F09%2F02%2Fbrowser-kuayu%2F</url>
    <content type="text"><![CDATA[跨域因为浏览器出于安全考虑，同源策略。也就是说，如果协议域名或者端口有一个不同就是跨域。Ajax请求会失败 我们可以通过以下几种常用方法解决跨域 ####JSONPJSONP的原理很简单，就是利用script标签没有跨域限制的漏洞。通过script标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。 123456&lt;script src="http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp"&gt;&lt;/script&gt;&lt;script&gt; function jsonp(data) &#123; console.log(data) &#125;&lt;/script&gt; JSONP使用简单且兼容性不错，但是仅限于get请求 在开发中会雨打多个JSONP请求的回调函数名字是相同的，这个时候就需要自己封装一个JSONP 12345678910111213141516function jsonp(url,jsonpCallback,success)&#123; let script = document.creatElement("script"); script.src = url; script.async = true; window[jsonpCallback] = function(data)&#123; success &amp;&amp; success(data); &#125;; document.body.appendChild(script);&#125;jsonp( "http://xxx", "callback", function(value)&#123; console.log(value); &#125;); CORSCORS 需要浏览器和后端同时支持。IE8 和 9 需要通过XDomainRequest来实现 浏览器会自动进行CORS通信，实现CORS通信的关键是后端，只要后端实现了CORS，就实现了跨域 服务端设置，Access-Control-Allow-Origin就可以开启CORS，该属性表示那些域名可以访问资源，如果设置通配符则表示所有网站可以访问资源。 document.domain该方式只能用于二级域名相同的情况下，比如a.test.com和b.test.com适用于该方式。 只需要给页面添加document.domain = ‘test.com’表示二级域名都相同就可以实现跨域。 postMessage这种方式通常用于嵌入页面的第三方页面数据，一个页面发送消息，另一个页面判断来源并接收消息 1234567891011//发送消息端window.parent.postMessage('message','http://test.com');//接收消息端var mc = new MessageChannel();mc.addEventListener('messge',(event)=&gt;&#123; var origin = event.origin || evnet.originalEvent.origin; if(origin == 'http://test.com')&#123; console.log('验证通过') &#125;&#125;);]]></content>
  </entry>
  <entry>
    <title><![CDATA[事件机制]]></title>
    <url>%2F2018%2F09%2F02%2Fbrowser-shijian%2F</url>
    <content type="text"><![CDATA[时间触发的三阶段时间触发有三个阶段 window 往事件触发处传播，遇到注册的捕获事件会触发 传播到时间触发处时触发注册的事件 从事件触发向window传播，遇到注册的冒泡事件会触发 事件触发一般来说会按照上边的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。 12345678// 以下会先打印冒泡然后是捕获node.addEventListener('click',(event) =&gt;&#123; console.log('冒泡')&#125;,false)node.adEventListener('click',(event)=&gt;&#123; console.log('捕获')&#125;,true) 注册事件 通常我们使用addEventListener注册事件，该函数的第三个参数值可以是布尔值，也可以是对象。对于布尔值uesCapture 参数来说，该参数默认值为false。 useCapture 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性。 capture， 布尔值，和useCapture作用一样 once， 布尔值，值为true 表示该回调只会调用一次，调用后会移除监听 passive， 布尔值，表示永远不会调用preventDefault 一般来说，我们只希望事件只触发在目标上，这时候可以使用stopPropagation来阻止事件的进一步传播。通常我们认为stopPropagation是用来阻止事件冒泡，其实该函数可以阻止捕获事件。stopImmediatePropagation同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。 1234567node.addEventListener('click',(event) =&gt;&#123; event.stopImmediatePropagation() console.log('冒泡')&#125;,false)node.addEventListener('click',(event)=&gt;&#123; console.log('捕获')&#125;,true) 事件代理如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上。 12345678910111213 &lt;ul id="ul"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; let ul = document.querySelector('##ul') ul.addEventListener('click', (event) =&gt; &#123; console.log(event.target); &#125;)&lt;/script&gt; 事件代理的方式相对于直接给目标注册事件来说，有以下优点 节省内存 不需要给子节点注销事件]]></content>
  </entry>
  <entry>
    <title><![CDATA[V8下的垃圾回收机制]]></title>
    <url>%2F2018%2F09%2F02%2FV8huishou%2F</url>
    <content type="text"><![CDATA[V8下的垃圾回收机制V8实现了准确式GC， GC孙啊发采用了分代式垃圾回收机制。因此V8将内存（堆）分为新生代和老生代两部分。 新生代算法新生代中对象一般存活的时间较短，使用Scavenger GC算法。 在新生代空间中，内存空间分为两部分，分别是From空间和To空间。这两个空间中，必有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入From空间中，当From空间被占满时，新生代GC就会启动了。算法会检查From空间中存活的对象并复制到To空间中，如果有失活对象就会销毁。当复制完成后将From空间和To空间互换，这样GC就结束了。 老生代算法老生代算法中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。 在讲算法之前，先来说说什么情况下对象会出现在老生代空间中： 新生代中的对象是否已经经历过一次Scaveng算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。 To空间的对象占比大小超过25%。在这种情况下，为了不影响内存分配，会将对象从新生代空间移到老生代空间中。 老生代中的空间很复杂，如下： 123456789101112131415enum AllocationSpace &#123; // TODD(v8:7464): Actually map this space's mermory as read-only. RO_SPACE, //不变的对象空间 NEW_SPACE, // 新生代用于GC复制算法空间 OLD_SPACE, // 老生代常驻对象空间 COOE_SPACE, // 老生代代码对象空间 MAP_SPACE, // 老生代map对象 LO_SPACE, // 老生代大空间对象 NEW_LO_SPACE, // 新生代大空间对象 FIRST_SPACE = RO_SPACE, LAST_SPACE = NEW_LO_SPACE, FIRST_GROWABLE_PAGED_SPACE = OLD_SPACE, LAST_GROWABLE_PAGED_SPACE = MAP_SAPCE&#125;; 在老生代中，以下情况会先启动标记清除算法： 某一个空间没有分块的时候 空间中被对象超过一定限制 空间中不能保证新生代中的对象移动到老生代中 在这个阶段，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011年，V8从stop-the-world标记切换到增量的标志。在增量标记期间，GC将标记工作分解为更小的模块，可以让JS应用逻辑在模块间隙执行一会儿，从而不至于让应用出现停顿的情况，但是在2018年，GC技术又有了一个重大突破，这个技术叫并发标记。该技术可以让GC扫描和标记对象时，同时允许JS运行。 清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清理掉不需要的内存]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[async和await]]></title>
    <url>%2F2018%2F08%2F31%2Fes6-async%2F</url>
    <content type="text"><![CDATA[async和awaitasync和await一个函数如果加上async，那么该函数会返回一个Promise。 1234async function test()&#123; return '1';&#125;console.log(test()); // -&gt; Promise&#123;&lt;resolved&gt;: "1"&#125; 可以把async看成是将函数返回值使用Promise。resolve() 包裹了。 await 只能在async函数中使用 12345678910111213function sleep()&#123; return new Promise(resolve =&gt;&#123; setTimeout(() =&gt;&#123; console.log('finish') resolve("sleep"); &#125;,2000); &#125;);&#125;async function test()&#123; let value = await sleep(); console.log("object");&#125;test() 上边的代码会先打印finish然后再打印object。因为await会等待sleep函数resolve，所以即使后面的是同步代码，也不会先去执行同步代码再来执行异步代码。 async和await相比直接使用Promise来说，有时下雨处理then的调用链，能够清晰准确的写出代码，缺点在于滥用await可能会导致性能问题，因为await会阻塞代码，也许之后的异步代码并不依赖于前者，但是仍需要等待前者完成，呆滞代码失去了并发性。 下面是await的代码 12345678910var a = 0;var b = async() =&gt; &#123; a = a + await 10 console.log("2",a) // -&gt; "2" 10 a = (await 10) + a console.log('3' ,a) // -&gt; '3' 20&#125;b()a++console.log('1',a)// -&gt; '1' 1\ 以下是代码原理 首先函数b先执行，在执行到 await 10 之前变量 a 还是 0， 因为在 await 内部实现了 generators , generator 会保留堆栈的东西，所以这时 a = 0 被保存下来。 因为 await是异步操作，遇到await就会立即返回一个pending状态的Promise对象，暂时返回执行代码的控制权，使得函数外的代码得以继续执行，所以先会执行console.log(‘1’,a) 这个时候同步代码执行完毕，开始执行异步代码，将保存下来的值拿出来使用，这个时候 a = 10 然后后面就是常规的代码执行 ProxyProxy 是ES6中的新增功能可以用来自定义对象中的操作。 123let p = new Proxy(target,handler);//`target`是代表需要添加处理对象// `handler` 用来自定义对象中的操作 可以很方便的使用Proxy来实现一个数据绑定和监听 1234567891011121314151617181920212223let onWatch = (obj,setBind,goyLogger) =&gt;&#123; let handler = &#123; get(target,preperty, receiver) &#123; getLogger(target,property) return Reflect.get(target,prooerty,receiver); &#125;, set(targ, property,value,receiver)&#123; setBind(value); return Reflect.set(targer,property,value); &#125; &#125;; return new Proxy(obj,handler);&#125;;let obj = &#123;a : 1&#125;let valuelet p = onWatch(obj, (v) =&gt; &#123; value = v;&#125;,(target,property) =&gt; &#123; console.log(`Get '$&#123;propert&#125;' = $&#123;target[property]&#125;`);&#125;)p.a = 2 // bind `value` to `2`p.a // Get `a` = 2]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Map FlatMap 和Reduce]]></title>
    <url>%2F2018%2F08%2F30%2FES6-map%2F</url>
    <content type="text"><![CDATA[Map 作用是生成一个新的数组，遍历原数组，将每个元素拿出来做一些交换，然后append 到新的数组中。 12[1,2,3].map((v) =&gt; v + 1)// -&gt;[2,3,4] Map 有三个参数，分别是当前索引元素，索引，原数组。 1234['1','2','3'].map(parseInt)// parseInt('1',0) -&gt; 1// parseInt('2',1) -&gt; NaN// parseInt('3',2) -&gt; NaN FlatMap 和 Map 的作用几乎是相同的，但是对于多维数组来说，会将原数降维。可以将 FlatMap 看成是 Map + flatten， 目前该函数在浏览器中还不支持。 12[1,[2],3].flatMap((v) =&gt; v+1)// -&gt; [2,3,4] 如果想将一个多维数组彻底的降维，可以这样实现。 12const flattenDeep = (arr) =&gt; Array.isArray(arr) ? arr.reduce( (a,b) =&gt; [...a,...flattenDeep(b)], []) : [arr]flattenDeep([1, [[2], [3, [4]],5]) Reduce 作用是数组中的值结合起来最终得到一个值。 123456789function a()&#123; console.log(1);&#125;function b()&#123; console.log(2);&#125;[a,b].reduce((a,b) =&gt; a(b()))// -&gt; 2 1]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Generator]]></title>
    <url>%2F2018%2F08%2F29%2FGenerator%2F</url>
    <content type="text"><![CDATA[Generator是ES6中新增的语法，和Promise一样，都可以用来异步编程。 12345678910111213// 使用* 表示这是一个Generator函数// 内部可以通过yield暂停代码// 通过调用next恢复执行function* test()&#123; let a = 1 + 2; yield 2; yield 3;&#125;let b = test();console.log(b.next());// &gt; &#123;value :2, done: false&#125;console.log(b.next()); // &gt; &#123;value: 3, done: false&#125;console.log(b.next()); // &gt; &#123;value: undefined, done: true&#125; 从以上代码可以发现，加上* 的执行函数后拥有了next 函数，也就是说函数执行后返回了一个对象，每次调用next 函数可以继续执行被暂停的代码。 Generator实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445//cb 也就是编译过的test函数function generator(cb)&#123; return(function()&#123; var object = &#123; next: 0, stop: function()&#123;&#125; &#125;; return&#123; next: function()&#123; var ret = cb(object); if(ret == undefined) return &#123;value: undefined, done: true&#125;; return&#123; value: ret, done: false &#125;; &#125; &#125;; &#125;)();&#125;// 如果 你使用babel 编译后可以发现test函数变样function test()&#123; var a; return generator(function(_context)&#123; while (1)&#123; switch((_context.prev = _context.next))&#123; // 可以发现通过 yield 将代码分割成几块 // 每次执行 next 函数就执行一块代码 // 并且表明下次需要执行哪块代码 case 0: a = 1 + 2; _context.next = 4; return 2; case 4: _context.next = 6; return 3; //执行完毕 case 6: case "end": return _context.stop(); &#125; &#125; &#125;);&#125;]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[set 和 map]]></title>
    <url>%2F2018%2F08%2F28%2Fes6-1%2F</url>
    <content type="text"><![CDATA[set 和 map 主要应用场景是数组去重和数据存储。但是准确来说，Set是”集合”,map 则是”字典”。 集合集合有以下几个特点： 集合是一组无序且唯一的项目组成的。可以想象成集合一个既没有重复元素，也没有顺序概念的数组 类似于数组，但是成员都是唯一的，不重复。 Set本身是一个构造函数，用来生成set数据结构 例如： 12345678const set = new Set();[2,3,5,4,5,2,3].forEach(x =&gt; set.add(x));for (let i of set)&#123; console.log(i);//2354;&#125;let array = [1,2,1,4,5,3][... new Set(array)] //[1,2,4,5,3] Set实例的属性和方法set的属性 size： 返回集合所包含元素的数量 set 的方法 add(value): 向集合添加一个新的项 delete(value): 删除一个值 has(value)判断是否存在一个值 clear()移除集合里所有的项 遍历方法： key() 返回一个包含集合中包含所有键的数组 value() 返回一个包含集合中的所有值得数组 entries() 返回一个包含集合中所有键值对的数组 forEach() 用于对集合成员执行某种操作 例如： 12345678910111213141516171819202122232425262728293031323334353637383940414243function Set(arr = [])&#123; arr.forEach((val,i) =&gt; &#123; this.add(val); &#125;) let items = &#123;&#125;; this.size = 0; // 记录集合中成员的数量 this.has = function(val)&#123; // 对象都有hasOwnProperty 方法，判断是否拥有特定属性 return items.hasOwnProperty(val); &#125; this.add = function(val)&#123; if(!this.has(val))&#123; items[val] = val; this.size ++; return true; &#125; return false; &#125; this.delete = function (val)&#123; if(this.has(val))&#123; delete items[val] this.size --; return true; &#125; return false; &#125;; this.clear = function()&#123; items = &#123;&#125;; this.size = 0; &#125;; this.keys = function()&#123; return Object.keys(itmes);// 返回遍历集合的所有键名的数组 &#125; this.values = function()&#123;// 返回遍历集合所有键值的数组 return Object.values(items); &#125; this.forEach = function(fn,context)&#123; for(let i = 0; i &lt; this.size; i++)&#123; let item = Object.keys(items)[i]; fn.call(context,item,item,itmes); &#125; &#125;&#125; union 并集和instersect并集 并集的数学概念，集合A和集合B的并集 交集的数学概念，集合A和集合B的交集 差集 1-AUB 例如： 123456789101112131415161718192021222324252627this.union = function(other)&#123; let union = new Set(); let Values = this.values(); for(let i = 0; i &lt; values.length; i++)&#123; union.add(value[i]); &#125; return union;&#125;this.intersect = function(otehr)&#123; let intersect = new Set(); let Values = this.values(); for(let i = 0; i &lt;values.length; i++)&#123; if(other.has(values[i]))&#123;// 查看是否也存在与other中 intersect.add(values[i]);//存在的话就是intersect中添加元素 &#125; &#125;&#125;this.difference = function(other)&#123; let difference = new Set(); let values = this.values(); for(let i =0; i&lt; values.length; i++)&#123; if(!other.has(values[i]))&#123;//将不存在于other集合中的添加到的新的集合中 difference.add(values[i]); &#125; &#125;&#125; 字典Map类的数据结构 共同点： 集合字典，都是存放不下重复的值 不同点： 集合是以[value,value]的形式存储元素，字典则是一[键,值]形式存储 Map其实的主要用途也是用于存储数据，相比Object只提供”字符串-值”的对应，map提供了”值-值” 对应，也就是说如果你需要键值对的数据结构，map比Object更合适。 123456789const m = new Map();const o = &#123; p : "hello w"&#125;m.set(o, 'content');m.get(o);//"content"m.has(o);//truem.delete(o)//truem.has(o)//false Map的属性和方法属性： size：返回字典所包含的元素个数操作方法： set(key, val): 向字典中添加新元素 get(key): 通过键值查找特定的数值并返回 has(key): 如果键值存在与字典中返回true，否则false delete(key): 通过键值来删除数据 clear(): 清空 遍历方法： keys(): 字典中包含的所有键名以数组形式返回 values(): 将字典中包含的所有数值以数组形式返回 forEach()：遍历字典的所有成员 例如 12345678910111213141516171819202122232425262728293031323334function Map()&#123; let item = &#123;&#125;; this.has = function(val)&#123; return items.hasOwnProperty(val); &#125;; this.set = function(key,val)&#123; items[key] = val; &#125; this.get = function(key)&#123; return this.has(key) ? items[key] : undefined; &#125; this.delete = function (key)&#123; if(this.has(key))&#123; delete items[key]; this.size --; return true; &#125; return false; &#125; this.clear = function()&#123; items = &#123;&#125;; this.size = 0; &#125; this.keys = function()&#123; return Object.keys(items); &#125; this.forEach = function(fn,context)&#123; for(let i = 0; i &lt; this.size; i++)&#123; let key = Object.keys[items][i]; let value = Object.values(items)[i]; fn.call(context,value,key,items); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue笔记(6)]]></title>
    <url>%2F2018%2F08%2F27%2Fvue-6%2F</url>
    <content type="text"><![CDATA[Slots分发内容使用组件是，为了让这个组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板，这个过程称为内容分发。Vue可以使用特殊的slot元素作为初始内容的插槽。 ##编译作用域 首先需要明确内容的编译作用域，假定模板为： 12&lt;child-component&gt;&lt;/child-component&gt; 这样的一个组件，message应该绑定在父组件中。 父组件模板的内容在父组件作用域内编译，子组件模板的内容在子组件作用域内编译。 一个常见的错误是试图在父组件模板内将一个指令绑定在子组件属性。 1&lt;child-component v-show="someChildProperty"&gt;&lt;/child-component&gt; 假如someChildProperty 是子组件的属性，上面的例子是不会工作的。因为父组件模板不应该知道子组件的状态。 正确的应该这么写： 12345678Vue.component('child-component'&#123; template: `&lt;div v-show="someChildProperty"&gt;Child&lt;/div&gt;`, data()&#123; return &#123; someChildProperty: true &#125; &#125;&#125;) 类似的，分发内容是在父组件作用域内编译 单个Slot 除非子组件模板包含至少一个接口，否则父组件的内容将会被丢弃，当子组件模板只有一个么日游属性的slot时，父组件整个内容整个内容片段将会插入到slot所在的DOM位置，并替换slot标签本身。 具名Slots slot元素可以用一个特殊的属性name来配置如何分发内容。多个slot可以有不同的名字。具名slot将匹配内容片段有对应的slot特性的元素。 仍然可以有一个匿名slot，它是默认slot，作为找不到匹配的内容片段的备用插槽。如果没有默认的slot，这些找不到匹配的内容片段将被抛弃。 12345678910111213141516171819202122232425262728293031323334&lt;div class="container"&gt; &lt;header&gt; &lt;slot name="header"&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name="footer"&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt;//父组件模板&lt;app-layout&gt; &lt;h1 slot="header&gt;Here might be a page title&lt;/h1&gt; &lt;p&gt; A paragraph for the main contet.&lt;/p&gt; &lt;p&gt; And another one.&lt;/p&gt; &lt;p slot="footer "&gt;Here is some contact info&lt;/p&gt;&lt;app-layout&gt;//渲染效果 &lt;div class=" container" &gt; &lt;header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;/main&gt; &lt;footer&gt; &lt;p&gt;Here's some contact info&lt;/p&gt; &lt;/footer&gt; &lt;/div&gt; 动态组件 多个组件可以使用同一个挂载点，然后动态的在它们之间切换。使用component元素，动态绑定它的is特性。 123456789101112131415161718 let vm = new Vue(&#123; el: "#example", data: &#123; currentView: 'home', &#125;, home: &#123; //... &#125;, posts: &#123; //... &#125;, archive: &#123; //... &#125; &#125;&#125;) ##keep-alive 如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个keep-alive指令参数： 12345 &lt;keep-alive&gt; &lt;component :is="currentView"&gt; &lt;!---非活动组件将被缓存---!&gt; &lt;/component&gt;&lt;/keep-alive&gt;]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise实现]]></title>
    <url>%2F2018%2F08%2F26%2FPromise%2F</url>
    <content type="text"><![CDATA[Promise是ES6新增的语法，解决了回调的问题 可以把Promise看成一个状态机。初始时pending状态，可以通过函数resolve和reject， 将状态转变为resolved或者rejected状态。状态一旦改变就不能再次变化。 then函数会返回一个Promise实例，并且该返回值是一个新的实例而不是之前的实例。因为Promise规范规定除了pending状态，其他状态是不可以改变的，如果返回的是一个相同实例的话，多个then调用就失去意义了。 对于then来说，本质上可以把它看成是flatMap 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170// 三种状态const PENDING = "pending";const RESOLVED = "resolved";const REJECTED = "rejected";// promise接受一个函数参数，该函数会立即执行。function MyPromise(fn)&#123; let _this = this; _this.currentState = PENDING; _this.value = undefined; // 用于保存then中的回调，只有当promise // 状态pending时才会缓存，并且每个实例最多缓存一个。 _this.resolveCallbacks = []; _this.rejectedCallbacks = []; _this.resolve = function(value)&#123; if(value instanceof MyPromise)&#123; // 如果value是个Promise递归执行 return value.then(_this.reolve,_this.reject) &#125; setTimout(()=&gt; &#123;//异步执行，保证执行顺序 if(_this.currentState === PENDING)&#123; _this.currentState = RESOLVED; _this.value = value; _this.resolvedCallbacks.forEach(cb =&gt; cb()); &#125; &#125;) &#125;; _this.reject = function(reason)&#123; setTimeout(()=&gt; &#123;//异步执行，保证执行顺序 if(_this.currentState === PENDING)&#123; _this.currentState = REJECTED; _this.value = reason; _this.rejectedCallbacks.forEach(cb=&gt; cb()); &#125; &#125;) &#125; // 用于解决以下问题 // new Promise(()=&gt; throw Error('error')) try &#123; fn(_this.resolve,_this.reject); &#125; catch (e)&#123; _this.reject(e); &#125;&#125;MyPromise.prototype.then = function (onResolved,onRejected)&#123; var self = this; //规范2.2.7 then 必须返回一个新的promise var promise2; // 规范 2.2.onResolved 和 onRejected 都为可选参数 // 如果类型不是函数需要忽略，同时也实现了透传 // Promise.resolve(4).then().then((value) =&gt; console.log(value)) onResolved = typeof onResolved === 'function' ? onResolved : v=&gt; v; onRejected = typeof onRejected ==='function' ? onRejected : r =&gt; throw r; if(self.currentState === RESOLVED)&#123; return(promise2 = new MyPromise(function(resolve,reject)&#123; // 规范 2.2.4，保证 onFulfilledset，onRjected 异步执行 // 所以用了 setTimeout 包裹下 setTimeout(function()&#123; try&#123; var x = onResolved(self.value); resolutionProducedure(promise2,x,resolve,reject); &#125;catch (reason)&#123; reject(reason); &#125; &#125;); &#125;));&#125; if (self.currentState === REJECTED) &#123; return (promise2 = new MyPromise(function (resolve, reject) &#123; setTimeout(function () &#123; // 异步执行onRejected try &#123; var x = onRejected(self.value); resolutionProcedure(promise2, x, resolve, reject); &#125; catch (reason) &#123; reject(reason); &#125; &#125;); &#125;)); &#125; if (self.currentState === PENDING) &#123; return (promise2 = new MyPromise(function (resolve, reject) &#123; self.resolvedCallbacks.push(function () &#123; // 考虑到可能会有报错，所以使用 try/catch 包裹 try &#123; var x = onResolved(self.value); resolutionProcedure(promise2, x, resolve, reject); &#125; catch (r) &#123; reject(r); &#125; &#125;); self.rejectedCallbacks.push(function () &#123; try &#123; var x = onRejected(self.value); resolutionProcedure(promise2, x, resolve, reject); &#125; catch (r) &#123; reject(r); &#125; &#125;); &#125;)); &#125;&#125;;// 规范 2.3function resolutionProcedure(promise2, x, resolve, reject) &#123; // 规范 2.3.1，x 不能和 promise2 相同，避免循环引用 if (promise2 === x) &#123; return reject(new TypeError("Error")); &#125; // 规范 2.3.2 // 如果 x 为 Promise，状态为 pending 需要继续等待否则执行 if (x instanceof MyPromise) &#123; if (x.currentState === PENDING) &#123; x.then(function (value) &#123; // 再次调用该函数是为了确认 x resolve 的 // 参数是什么类型，如果是基本类型就再次 resolve // 把值传给下个 then resolutionProcedure(promise2, value, resolve, reject); &#125;, reject); &#125; else &#123; x.then(resolve, reject); &#125; return; &#125; // 规范 2.3.3.3.3 // reject 或者 resolve 其中一个执行过得话，忽略其他的 let called = false; // 规范 2.3.3，判断 x 是否为对象或者函数 if (x !== null &amp;&amp; (typeof x === "object" || typeof x === "function")) &#123; // 规范 2.3.3.2，如果不能取出 then，就 reject try &#123; // 规范 2.3.3.1 let then = x.then; // 如果 then 是函数，调用 x.then if (typeof then === "function") &#123; // 规范 2.3.3.3 then.call( x, y =&gt; &#123; if (called) return; called = true; // 规范 2.3.3.3.1 resolutionProcedure(promise2, y, resolve, reject); &#125;, e =&gt; &#123; if (called) return; called = true; reject(e); &#125; ); &#125; else &#123; // 规范 2.3.3.4 resolve(x); &#125; &#125; catch (e) &#123; if (called) return; called = true; reject(e); &#125; &#125; else &#123; // 规范 2.3.4，x 为基本类型 resolve(x); &#125;&#125; 以上就是根据Promise/A+ 规范来实现的代码，可以通过promise-aplus-tests的完整测试。]]></content>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call apply bind 的区别]]></title>
    <url>%2F2018%2F08%2F25%2Fcall%20bind%2F</url>
    <content type="text"><![CDATA[首先说下前两者的区别。 call 和 apply 都是为了改变 this指向。作用是相同的，只是传参的方式不同。除了第一个参数外， call 可以接收一个参数列表，apply只能接受一个参数数组。 12345678910let a = &#123; value: 1&#125;function getValue(name,age)&#123; console.log(name) console.log(age) console.log(this.value)&#125;getValue.call(a,'gyf','20')getValue.apply(a,['gyf','20']) ##模拟实现call 和 apply 可以从一下啊几点来考虑 不传入第一个参数，那么默认为window 改变this指向，让新的对象可以执行该函数，那么私立是否可以变成给新的对象添加一个函数，然后在执行完成后删除。 12345678910111213Function.prototype.myCall = function(context)&#123; var context = context || window // 给context添加一个属性 // getValue.call(a,'gyf','20') =&gt; a.fn = getValue context.fn = this //将context后边的参数取出来 var args = [...arguments].slice(1) // getValue.call(a,'gyf','20') =&gt; a.fn('gyf','20') var result = context.fn(...args) //删除fn delete context.fn return result&#125; 以上是call的思路 apply也类似 12345678910111213141516Function.prototype.myApply = function(context)&#123; var context = context || window context.fn = this var result // 需要判断是否存储第二个参数 // 如果存在就将第二个参数展开 if(arguments[1])&#123; result = context.fn(...arguments[1]) &#125;else&#123; result = context.fn() &#125; delete context.fn return result&#125; bind 和其他两个方法的作用也是一致的，只是该方法会返回一个函数，并且我们可以通过bind实现柯里化。 实现模拟bind 123456789101112131415Function.prototype.myBind = function(context)&#123; if(typeof this !== 'function')&#123; throw new TypeError('error') &#125; var _this = this var args = [...arguments].slice(1) //返回一个函数 return function F()&#123; // 因为返回了一个函数，我们可以new F() 所以需要判断 if(this instanceof F)&#123; return new _this(...args,...arguments) &#125; return _this.apply(context,args.contcat(...agruments)) &#125;&#125;]]></content>
      <tags>
        <tag>javscript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue笔记(5)]]></title>
    <url>%2F2018%2F08%2F21%2Fvue-5%2F</url>
    <content type="text"><![CDATA[组件组件是实现复用的一个重要的手段，也是前端提高开发效率的一个重要的途径。那么vue中的组件化也是很重要的概念。 注册 1234Vue.component('my-component',&#123; //options template: "&lt;div&gt;hello, here is a componenet&lt;/div&gt;"&#125;) 然后我们可以在HTML中使用这个组件了。要注意的是，组件必须要注册之后才能使用，即需要写在vue的对象之前。 局部注册 当然我们不用在全局注册每个组。通过使用组件实例选项注册，可以使组件仅在另一个实例的作用域可用。 123456789let ChildComponent = &#123; template: "&lt;div&gt; here is a one of Component&lt;/div&gt;"&#125;new Vue(&#123; el : "#example", component: &#123; 'my-component':ChildComponent &#125;&#125;) data 必须是函数使用组件是，大多数选项可以传到Vue构造器中，有一个例外是，data必须是函数。 12345678910let obj = &#123; counter: 0&#125;Vue.componet('Counter',&#123; template: "&lt;button v-on:click="counter +=1"&gt;counter&lt;/button&gt;", data: function()&#123; return &#123;counter: 0&#125;;//这是返回一个对象 return obj;// 这只是返回一个引用，这样会导致组件共用一个counter &#125;&#125;) 构成组件 组件意味着协同工作，通常父子组件会存在相互之间的通信。这样，父子组件的解耦就很重要了。为了保证每个组件可以相对隔离的环江中书写和理解，提高组件的可维护性和可复用性。 Props 组件实例的作用域是孤立的。这意味着不能并且不应该在子组件的模板内直接引用父组件的数据。可以使用props吧数据传给子组件。 12345Vue.component('child',&#123; props : "['messgae']", template: '&lt;span&gt;&lt;/span&gt;'&#125;)&lt;child message="hello"&gt;&lt;/child&gt; 有需要注意的是，如果在props里面使用的是形如myMessage的camelCase那么在HTML里边就需要改为my-message。 当然，我们可以用v-bind动态绑定props的值到父组件的数据中。每当父组件的数据变化时，改变化也会传递到子组件中。 1234&lt;div&gt; &lt;input v-model="parentMsg"&gt; &lt;child :my-message="parentMsg"&gt;&lt;/child&gt;&lt;/div&gt; 字面量语法和动态语法。 12&lt;comp some-prop="1"&gt;&lt;/comp&gt;//传递的是一个字符串1&lt;comp v-bind:some-prop="1"&gt;&lt;/comp&gt; // 传递的是实际的数字 单向数据流 prop 是单向绑定的。当父组件的属性变化时，将传递给子组件，但是不会反过来。 另外每次父组件更新时，子组件的所有props都会更新，所以子组件内部的props不能改变。 通常会有两种改变prop的情况： prop作为初始值传入，子组件之后只是将它的初始值作为本地数据的初始值使用123456props: ['initalcounter'],data: function()&#123; return &#123; counter: this.initalcounter &#125;&#125; prop 作为需要别改变的原始值传入 123456props : ['size'],computed: &#123; normalizedSize:function()&#123; return this.size.trim().toLowerCase() &#125;&#125; ##自定义事件。 父组件通过props传递数据给子组件，如果父组件要把数据传递回去，就需要使用自定义事件，每个Vue实例都实现事件接口 使用 $on(eventName)监听事件 使用 $emit(eventName)触发事件 父组件可以在使用子组件的地方直接使用v-on来监听子组件触发的事件 123456789101112131415161718192021222324252627282930 &lt;div id="counter-event-example"&gt; &lt;p&gt;&lt;/p&gt; &lt;button-counter v-on:increment="incrementTotal"&gt;&lt;/button-counter&gt; &lt;button-counter v-on:increment="incrementTotal"&gt;&lt;/button-counter&gt;&lt;/div&gt;Vue.component('button-counter', &#123; template: "&lt;button v-on:click=increment"&gt;&lt;/button&gt;",// 监听一个点击事件，点击了之后，会触发increment方法 data: function () &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; increment: function () &#123; this.counter += 1; // 自身的counter加1，之后 this.$emit('increment') // 触发props的increment &#125; &#125;&#125;)new Vue(&#123; el: "#counter-event-example", data: &#123; total: 0 &#125;, methods: &#123; incrementTotal: function () &#123; // 来自子组件的触发源 this.total += 1; &#125; &#125;&#125;) 使用自定义事件的表单输入组件自定义事件也可以用来创造自定义的表单输入组件，使用v-model来进行数据的双向绑定。 1&lt;input v-model="something"&gt; 仅仅是一个语法堂 1&lt;input v-bind: value="something" v-on:input="something" = $event.target.value"&gt; 所以在组件使用时，相当于下边简写。 1&lt;input v-bind:value="something" v-on:input="something=argument[0]"&gt; 所以要让组建的v-model生效，必须： 接受一个value属性 再有新的value时触发input事件 非父子之间通信简单场景下可以使用空vue实例作为中央事件总线 1234567let bus = new Vue();// component A to emitbus.$emit('id-selected',1);//component B to spybus.$on('id-selected',function(id)&#123; //&#125;) 如果场景复杂需要专门的状态管理模式。]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue笔记(4)]]></title>
    <url>%2F2018%2F08%2F21%2Fvue-4%2F</url>
    <content type="text"><![CDATA[事件处理之前讲过v-on指令可以绑定事件 123456789101112&lt;div id = "exampel-1"&gt; &lt;button v-on:click="handleFun"&gt;ClickHere&lt;/button&gt;&lt;/div&gt;// jslet vm = new Vue(&#123; el : "#example-1", methods : &#123; handleFun : function()&#123; console.log('you click') &#125; &#125;&#125;) 如果需要再内联语句处理器中访问原始的DOM事件。可以用特殊变量￥event把它传递进函数中。 12345678910&lt;button @click= "send('hello',$event)"&gt; Submit&lt;button&gt;// jsmethods:&#123; send: function(message,event)&#123; if(event) event.preventDefault(); alert(message); &#125;&#125; 事件修饰符 在事件处理程序中调用event.preventDefault() 或event.stopPropagation() 是常见的需求。我们需要的是，方法中只有纯粹的数据逻辑，而不是去处理DOM事件细节。 为了解决这个问题，我们可以使用事件修饰符，之前说修饰符是由 ‘.’ 打头的指令后缀表示的。 stop 阻止单击事件继续传播 prevent 阻止默认事件 capture 事件捕获 self 只有在事件在元素本身上触发才会有效即不能冒泡和捕获 once 点击事件只会触发一次 12345&lt;a v-on: click.stop="doThis"&gt;no send&lt;/a&gt;//阻止单击事件传播&lt;form v-on:sumbit.prevent="onSubmit"&gt;&lt;/form&gt;//提交时间不在重载页面&lt;a v-on:click.stop.prevent="doThat"&gt;&lt;/a&gt;//修饰符可以串联&lt;div v-on:click.capture="doThis"&gt;.....&lt;/div&gt;//添加事件监听时使用事件捕获，即元素自身触发的事件先在此处处理，然后才交给内部元素进行处理&lt;div v-on:click.self="doThat"&gt;.....&lt;/div&gt;//是当前元素自身时触发处理函数。即事件不是从内部元素触发的。 要注意： 在使用修饰符的时候，顺序很重要，相应的代码会以同样的顺序产生。因此，使用v-on:click.prevent.self 会阻止所有的点击，而v-on:click.self.prevent只会阻止对元素自身的点击。 按键修饰符这个是用来监听键盘事件的 1&lt;input v-on:keyup.13="submit"&gt;//监听keyCode为13的事件。 当然针对常用的keyCode可以使用别名 enter tab delete esc space up down left right 如果没有合适的还可以自定义按键修饰别名 1Vue.config.keyCodes.f1 = 112; 系统修饰键 可以使用如下修饰符来实现仅在按下相应的鼠标或者事件的监听器。 ctrl alt shift meta 12&lt;input @key.alt.67="clear"&gt; // Alt + c&lt;div @click.ctrl="handle"&gt;click&lt;/div&gt;// Ctrl + click 所有HTML中监听的事件，当viewmodel 被销毁，所有的时间处理器会被自动销毁。 表单输入绑定 12345678910111213141516&lt;select v-model="selected"&gt; &lt;option v-for = "option in options" v-bind: value="option.value"&gt; &lt;/option&gt;&lt;/select&gt;new Vue(&#123; el : "example", data : &#123; selected : "A", options: [ &#123;text: 'one', value: 'A'&#125;, &#123;text : 'two', value: 'B'&#125;, &#123;text : 'three', value: 'C'&#125; ] &#125;&#125;)]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue笔记(3)]]></title>
    <url>%2F2018%2F08%2F20%2Fvue-3%2F</url>
    <content type="text"><![CDATA[条件渲染之前提过v-if这个指令，今天详细说。 v-if 和 v-else 12&lt;h1 v-if="ok"&gt;Ok&lt;/h1&gt;&lt;h1 v-else&gt;No&lt;/h1&gt; 是否渲染，就取决于ok的Boolean值 v-else-if 不难理解，v-else-if是在v-if语句后面，泳衣匹配其他情况。 123&lt;div v-if="type=== A"&gt;A&lt;/div&gt;&lt;div v-else-if="type===B"&gt;B&lt;/div&gt;&lt;div v-else="type=== C"&gt;C&lt;/div&gt; 用key管理可重复性的元素 1234567891011121314151617 &lt;template v-if="loginType === 'username'"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder="Enter your username"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder="Enter your email address"&gt;&lt;/template&gt;// 使用key管理&lt;template v-if="loginType === 'username'"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder="Enter your username" key="username-input"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder="Enter your email address" key="email-input"&gt;&lt;/template&gt; 两者的区别在于，前者在切换unsername和Email的时候，input不会重新渲染，这样如果input里边有输入，这样就会被保留到下次的input中。当如果有key时，表示input自动重新渲染，但是要保证key值不同。 v-show另外一个根据条件来渲染的v-show 1&lt;div v-show="needshow"&gt;Hi&lt;/div&gt; v-show的元素始终会被渲染并且保留在DOM中。v-show只是简单切换元素的css属性display。 至于v-if，是真正的渲染，它会确保在切换过程中条件块内的时间监听器和子组件适当的被销毁重建。而v-show则只是改变display的值。 所以，根据场景，如果任务只是需要简单控制是否需要显示，则使用show就ok，如果会有复杂的逻辑判断就要用v-if。 列表渲染v-forv-for可以把一个数组对应成为一组元素，根据一组数组的选项列表进行渲染。v-for需要使用item in item形式的特殊语法，items是源数据数组并且item是数组元素迭代的别名。 12345678910111213&lt;ul id = "example1"&gt; &lt;li v-for="item in items"&gt; &lt;/li&gt;&lt;/ul&gt;var example1 = new Vue(&#123; el : "#example1", data : &#123; items :[ &#123;message : 'foo'&#125;, &#123;message : 'bar'&#125; ] &#125;&#125;) v-for 支持第二个参数，用来表示数组的索引。 12345678910111213141516&lt;ul id = "example-2"&gt; &lt;li v-for = "(item,index) in items"&gt; &lt;/li&gt;&lt;/ul&gt;var example = new Vue(&#123; el : "#example-2", data : &#123; parentMessage : "Parent", items : [ &#123;message: 'foo'&#125;, &#123;message: 'bar'&#125; ] &#125;&#125;) 对象的v-for 12345678910111213141516&lt;ul id = "v-for-object" class= "demo"&gt; &lt;li v-for="value in object"&gt; &lt;/li&gt;&lt;/ul&gt;//jsnew Vue(&#123; el "#v-for-object", data : &#123; object : &#123; firstName: "Gao", lastName : "fei" age : 20 &#125; &#125;&#125;) 同样可以传入第二个参数，表示对象的键值。 12345678910&lt;div v-for="(value,key) in object"&gt; ...&lt;/div&gt;//jsdata : &#123; object :&#123; name : "gao" age : 20 &#125;&#125; 注意需要注意的是，当我们使用v-for进行更新已经渲染过的列表的时候，默认会使用复用的方法，如果数据项的顺序被改变，vue将不会移动DOM元素匹配数据项的顺序，而是简单重复此处每个元素，并且保证它在特定的索引下显示已经被渲染过的每个元素，类似于之前说过的input框的复用。 所以这里需要使用key值，追踪每个节点的身份，为 每个item提供唯一的可以属性。理想的key值每项都应有一个id。 1&lt;div v-for="item in items" :key="item.id"&gt;&lt;/div&gt; 特有数组方法 push() pop() shift() unshift() splice() sort() reverse() 这些方法是可以改变原有的数组，filter()concat() slice() 就会别改变原数组。但是他们会返回一个新的数组。 attention 利用索引直接设置item时，不会触发渲染，利用length直接修改长度，不会触发重新渲染。 1234567let vm = new Vue(&#123; data : &#123; items : ['a','b','c'] &#125;&#125;)vm.items[1] = 'x';//不会触发渲染，不是响应式。vm.items.length = 2; //同上 这个时候V型用se天进行操作 12vm.$set(vm.items, indexOfItem,newValue);vm.items.splice(newLength)// 解决第二个问题 对象更改监测 首先知道vue无法检测对象属性的添加删除，但是可以响应式添加属性，即Vue.set (vm.$set 也可以但它是全局Vue.set的别名) 1vue.set(vm.obj, 'age', 20); 当需要为对象添加对个新属性的时候，可以使用Object.assign() 或 _.extend() 形式如下 1234vm.userProfile = Object.assgin(&#123;&#125;, vm.userProfile,&#123; age : 27, favoriteColor: "Vue Green"&#125;) 显示过滤/排序的结果当我们想显示一个数组的过滤或者排序副本，而不实际该百年或重置原数据，这个时候可以创建返回过滤或者排序数组的计算属性。 12345678910111213141516171819202122&lt;li v-for= "n in eventNumbers"&gt;&lt;/li&gt;data : &#123; numbers:[1,2,3,4,5]&#125;,computed: &#123; eventNumbers : function()&#123; return this.numbers.filter((number)=&gt;&#123; return number % 2===0; &#125;) &#125;&#125;//methods methods: &#123; even: function(numbers)&#123; return numbers.filter((number)=&gt;&#123; return number % 2 ===0; &#125;) &#125;&#125;v-for="n in event(number)" v-for v-if 综合在同一个dom里面，v-for的优先级比v-if高，这就是v-if将分别重复运行与两个v-for循环中，如果想为仅有的一些渲染节点，可以用 12&lt;li v-for = "todo in todos" v-if = "!todo.isComplete"&gt;&lt;/li&gt; 这个可以用来做一个todoscomponent]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue笔记(2)]]></title>
    <url>%2F2018%2F08%2F19%2Fvue-2%2F</url>
    <content type="text"><![CDATA[计算属性模板内如果放入太多逻辑会让模板过重难以维护。example 123&lt;div id="example"&gt;&lt;/div&gt; 这样模板不在是简单的声明逻辑，比较复杂，不能一眼看出来，这个时候需要计算属性。 1234567891011let vm = new Vue(&#123; el: "#example", data : &#123; message: 'hello' &#125;, computed: &#123; reversedMessage: function()&#123; return this.message.split('').reverse().join(''); &#125; &#125;&#125;) computed VS methods如果在methods中添加computed的方法，其实也可以实现相同的功能。 12345methods : &#123; reversedMessage: function()&#123; return this.message.split('').reverse().join('') &#125;&#125; 但是，computed和methods两者的实现还是有去别的。计算属性是基于它们的来进行缓存的。只有在它的相关依赖发生改变的时候才会重新要求值。这就意味着，只要message还没有发生改变，多次访问reversdMessage，计算属性会立即返回之前的计算结果，而不会再次执行函数。 同样以下例子不会更新 12345computed: &#123; now : function()&#123; return Date.now() &#125;&#125;//因为now不是响应式依赖 conputed 使用情景假设我们有一个开销比较大的计算属性A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有气的计算属性依赖A。如果没有缓存，我们可能需要更多次执行A的getter。所以损耗性能且不需要时常更新的情景，我们可以使用计算属性。 computed VS watchVue 提供了一种更通用的方式来观察相应的Vue 的实例上数据变动，监听属性。当数据需要随着其他的数据变化而变动时，watch很容易被滥用，但是通常更好的方法是使用计算属性，而不是命令式的watch回调。 123456789101112131415161718192021 let vm = new Vue(&#123; el : "#demo", data : &#123; firstName : 'hh', lastName : 'jj', fullName : 'hhjj' &#125;, watch : &#123; firstName : function(val)&#123; this.fullName = `$&#123;this.lastName&#125;` &#125;, lastName : function(val)&#123; this.fullName = `$&#123;this.firstName&#125; $&#123;val&#125;` &#125; &#125; &#125;)// 改用computedcomputed : function(val)&#123; return this.fullName = `$&#123;this.firstName&#125; $&#123;this.lastName&#125;`&#125; 这样的代码量少，易懂。 setter那么对于计算属性中的方法，可以为其添加特定的setter 的函数，在对其进行set操作的时候，可以进行特定的操作。 12345678computed :&#123; // ... set : function(newValue)&#123; let names = new Value.split(' '); this.firstName = names[0]; this.lastName = names[names.length - 1]; &#125;&#125; 然后当我们输入vm.fullName = “John Doe” 的时候，setter会被调用,vm.firstName 和 vm.lastName 也会被相应的更新。 class和style绑定 操作元素的class列表和内联样式是数据绑定的一个常见的需求，因为他们都是属性，所以我们可以用v-bind处理。对于需要字符串拼接的class和style，应该怎么办？ 绑定HTMLclass对象语法 1&lt;div v-bind:class = "&#123;active:isActive, 'text-danger', hasError&#125;"&gt;&lt;/div&gt; active 取决于isActive的布尔值。text-danger取决于hasError的值。 也可以将对象提出来放在data里面。 1234567&lt;div v-bind:class = "classObject"&gt;&lt;/div&gt;data : &#123; classObject: &#123; active : true, 'text-dange:' : false &#125;&#125; 数组语法 1234567&lt;div v-bind:class="[activeClass,errorClass]"&gt;&lt;/div&gt;data : &#123; activeClass：'active', errorClass: 'text-danger'&#125;// 结果&lt;div class ="active text-danger"&gt;&lt;/div&gt; ##绑定style 对于style的绑定同样是采用驼峰式命名。 123&lt;div v-bind:style="&#123;color:activeColor,fontSize:fontSize + 'px'&#125;"&gt;&lt;/div&gt;&lt;div v-bind:style="styleObject"&gt;&lt;/div&gt;&lt;div v-bind:style="[baseStyles, overridingStyles]"&gt;&lt;/div&gt; 总结 computed，计算属性，与methods区别在于computed存在缓存，只用与当源对象改变得时候才会重新计算，适用与不频繁改变的情况。 watch不能滥用 v-bind：style和v-bind:class的对象语法和数组语法。]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 笔记(1)]]></title>
    <url>%2F2018%2F08%2F18%2Fvue-1%2F</url>
    <content type="text"><![CDATA[创建一个vue实例传入一个对象，有几个关键字段 el: 绑定节点，在这个节点上进行Vue的各种操作 data表示vue对象中将需要用的数据 example1 12345678910let vm = new Vue(&#123;//vm 是viewModel data:&#123; newTodoText: '', visitCount: 0, hideCompletedTodos: false, todos: [], error: null, test: &#123;&#125; &#125;&#125;) 如果想阻止修改现有的属性可以用ES5提供的freeze()方法 1234test = &#123;a : 234&#125;;Object.freeze(test);test.a = '1234';console.log(test) // &#123;a : 234&#125; 除了数据属性，Vue实例还暴露了一些常用的实例属性与方法。都有前缀$,用来与用户定义的属性进行区分。 12345678910 // example1 添加 let data = &#123;a : 1&#125;; let vm .... ... data : datavm.$data === data; //truevm.$el === document.getElementById('example')//truevm.$watch('a',function (newValue,oldValue)&#123; // this callback will excaute after 'a' change&#125;) 实现生命周期钩子每个Vue实例在被创建时都要经过一系列的初始化过程，如需要设置数据监听，编译模板，将实例挂载到DOM并在数据变化时更新DOM。这个过程，可以通过生命周期给不同节点进行不同操作。 另外需要注意的是，不能再生命周期函数上面使用箭层函数，因为this会被绑定而不指向vue实例 例如： created： 用来在一个实例被创建之后执行代码（可以对应到React中ComponentWillMount） 12345678new Vue(&#123; data : &#123; a :1, &#125;, created : function()&#123; console.log('a is: ' + this.a); &#125;&#125;) 模板语法vue将模板编译成虚拟DOM渲染函数。可以计算出最少需要重新渲染的组件，将DOM操作降到最少。不使用模板语法的话，可以直接通过render函数，或者JSX语法进行实现。 插值通过’’ 形式进行文本插值，如果希望数据只修改一次就可以使用v-once。可以通过v-html 指令直接输出HTML v-html ： 指令，将数据输出真正的HTML 1234567let vm = new Vue(&#123; el : '#app', data : &#123; rawHtml : "&lt;p&gt; hello world&lt;/p&gt;" &#125;,&#125;)&lt;div v-html = "rawHtml" id = "app"&gt; “”这种语法不能作用与HTML特性上，这时候应该使用v-bind指令 1&lt;div v-bind:id = "theid"&gt;&lt;/div&gt; 这样这个div的id 就是theid了。v-bind还能使用布尔值，true就为此添加属性，否则不添加。这个可以用来操作样式。 使用JavaScript表达式 1&lt;div v-bind:id = " 'list-' +id"&gt;&lt;/div&gt; 这些表达式会在所属的vue实例的数据作用域下作为Javascript被解析。但是每个绑定都只能包含单个表达式。 1if(o)&#123;return message&#125; // 流程控制不行，是使用三元表达式 指令带有v-前缀的特殊特性，指令特性的值预期是单个Javascript的表达式。指令的职责是当表达式改变时，将其产生的连带影响，响应式地应用dom。 v-if 将根据表达式的值真假来插入或移除值。 1&lt;p v-if = "seen"&gt;hello&lt;/p&gt; v-bind：用于响应式地更新HTML的特性，根据情况可以传参数。 12&lt;a v-bind:href="url"&gt;&lt;/a&gt;//这里的href就是参数，告诉v-bind指令将这个元素的href属性与表达式url值绑定。 v-on: 拥有绑定事件，后面要跟一个参数，表示时间类型。 修饰符修饰符是以半角句号’.’,指定特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，prevent修饰符是告诉v-on指令对于触发事件调用evnet.preventDefault() 1&lt;form v-on:submit.prevent="onSumbit"&gt; 指令缩写 v-bind： ‘:’ 1&lt;a :href="url"&gt;&lt;/a&gt; v-on “@” 1&lt;button @click= "dosomething"&gt;&lt;/button&gt; 复习 Vue实例，data字段，el字段 基本语法，插值 指令 v-html 用于直接输出HTML； v-if用于判断条件进行操作；v-bind，用于绑定HTML特性，缩写为 ‘:’ v-on用于绑定事件 ‘@’. 生命周期的钩子，created mounted render。 要注意的是，不能再里面使用箭层函数，这样会导致this指向改为父级，而不是vue实例。]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[防抖 节流 继承]]></title>
    <url>%2F2018%2F08%2F18%2Fes6%20jicheng%2F</url>
    <content type="text"><![CDATA[防抖你是否在日常开发中遇到一个问题，在滚动事件中需要做个复杂计算或实现一个按钮的防二次点击操作。 这些需求都可以通过函数的防抖来实现。尤其是第一个，如歌在频繁的事件回掉中做复杂加us安很有可能导致页面卡顿，不如将多次计算合为一次，只在一个精确点操作。因为防抖的轮子很多，也不要自己写，直接使用underscore的源码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*** underscore 防抖函数，返回战术连续调用时，空闲时间必须大于或等于wait，function 才会执行* * @param &#123;function&#125; func 回调函数* @param &#123;number&#125; wait 表示时间窗口的间隔* @param &#123;boolean&#125; immediate 设置为ture 时，是否立即调用函数* @return &#123;function&#125; 返回客户调用函数*/_.debounce = function(func,wait,immediate)&#123; var timeout, args, context, timestamp, result; var later = function()&#123; //现在和上一次时间戳比较 var last = _.now() - timestamp; // 如果当前间隔时间少于设定时间且大于0就重新设置定时器 if(last &lt; wait &amp;&amp; last &gt;=0)&#123; timeout = setTimeout(later, wait - last); &#125;else&#123; //否则的话就是时间到了执行回调函数 timeout = null; if(!immediate)&#123; result = func.apply(context,args); if(!timeout) context = args = null; &#125; &#125; &#125;; return function()&#123; context = this; args = arguments; //获得时间戳 timestamp = _.now(); //如果定时器不存在且立即执行函数 var callNow = immediate &amp;&amp; !timeout; // 如果定时器不存在就创建一个 if(!tiemout) timeout = setTimeout(later,wait); if(callNow)&#123; //如果需要立即执行函数通过apply执行 result = func.apply(context,args); context = args = null; &#125; return result; &#125;;&#125; 整体函数实现不难总结一下。 对于按钮防点击来说：一旦我开始一个定时器，只要我定时器还在，不管你怎么点击都不会执行回调函数。一旦定时器结束并设置为null，就可以再次点击。 对于延时执行函数来说： 每次调用防抖函数都会判断本次调用和之前的时间间隔，如果小于需要的时间间隔，就会重新创建一个定时器，并且定时器的延时为设定时间减去之前的时间间隔，一旦时间到了，就会执行相应的回调函数。 节流防抖和节流的本质是不一样的。防抖是将多次执行变为最后一次执行，节流是将多次执行变成隔一段时间执行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/*** underscore 节流函数，返回函数连续调用时，func执行频率限定为 次 / wait* @param &#123;function&#125; func 回调函数* @param &#123;number&#125; wait 表示时间窗口间隔* @param &#123;object&#125; options 如果想忽略开始函数的调用，传入&#123;leading：false&#125;* 如果想忽略结尾函数的调用，传入&#123;trailing：false&#125;* 两者不能共存否则函数不能执行* @return &#123;function&#125; 返回客户调用函数*/_.throttle = function (func, wait, options)&#123; var context, args, result; var timeout = null; //之前的时间戳 var pervious = 0; // 如果options 没传则设为空对象 if(!options) options = &#123;&#125;; //定时器回调函数 var later = function()&#123; // 如果设置了 leading，将previous设为0； // 用于下面函数的第一个if判断 previous = options.leading === false ? 0 : _.now(); //置空一是为了防止内存泄漏，二是为了下面定时器判断 timeout = null; result = func.apply(context,args); if(!timeout)context = args = null; &#125;; return function ()&#123; // 获得当前时间戳 var now = -.now(); // 首次进入前者肯定为true // 如果需要第一次不执行函数 // 就将上次时间戳设为当前的 // 这样在计算下来remaining 的值会大于0 if(!previous &amp;&amp; options.leading === false)previous = now; //计算剩余时间 var remaining = wait - (now - previous); context = this; args = arguments; //如果当前调用已经大于上次调用的时间 + wait // 或者用户手动调了时间 // 如果设置trailing 只会进入这个条件 // 如果没有设置leading 那么第一次会进入这个条件 // 还有，你可能觉得开启了定时器那么不应该进入这个if条件 // 其实还是会进入的。因为定时器的延迟 // 并不是准确时间，很可能你设置了2秒 // 但是他要2.2秒触发，这时候才会进入这个条件 if(remaining &lt;= 0 || remaining &gt; wait)&#123; //如果存在定时器就会被清理掉好否则会调用二次回调 if(timeout)&#123; clearTimeout(timeout); timeout = null; &#125; previous = now; result = func.apply(context,args); if(!timeout) context = args = null; &#125;else if(!timeout &amp;&amp; options.trailing !== false)&#123; //判断是否设置了定时器和trailing //如果没有就开启一个定时器 // 并且不能同时设置leading trailing timeout = setTimout(later,remaining); &#125; return result; &#125;;&#125; 继承在ES5中，我们可以使用如下方法解决继承的问题。 123456789101112131415function Super()&#123;&#125;Super.prototype.getNumber = function()&#123; return 1&#125;function Sub()&#123;&#125;let s = new Sub()Sub.prototype = Object.create(Super.prototype, &#123; constructor : &#123; value: Sub, enumerable: false, writable: true, configurable: true &#125;&#125;) 以上继承实现思路就是将子类的原型设置为父类的原型 在ES6中，我们可以通过class 语法轻松解决这个问题 1234567class myDate extends Date&#123; test()&#123; return this.getTime() &#125;&#125;let myDate = new myDate()myDate.test() 但是ES6不是所有浏览器都兼容，所以我们需要Babel来编译这段代码。如果你使编译过的代码 myDate() 有报错 因为在js底层有限制，如果不是由Date构造出来的实例的话，是不能调用Date里的函数。所以侧面说明，ES6中class 继承与ES5中方法不同 既然底层限制了实例必须有Date 构造出来，那么我们可以改变思路实现继承 123456789function MyDate()&#123;&#125;MyDate.prototype.test = function()&#123; return this.getTime()&#125;let d = new Date()Object.setPrototypeOf(d,MyDate,prototype)Object.setPrototypeOf(MyDate.prototype,Date.prototype) 以上继承实现思路：先创建父类实例=&gt; 改变实例原先的proto 转而连接到子类的prototype =&gt; 子类的 prototype 的 proto 改为父类的 prototype。 通过以上方法实现的继承就可以完美解决 JS 底层的这个限制。]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>Es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深浅拷贝 模块化]]></title>
    <url>%2F2018%2F08%2F14%2Fkaobei%20mokuai%2F</url>
    <content type="text"><![CDATA[123456let a = &#123; age : 1&#125;let b = aa.age = 2console.log(b.age)//2 深浅拷贝从上述例子可以发现，如果给一个变量赋值一个对象，那么两者的值会是同一个引用，其中一方改变，另一方也改变。 通常在开发中我们不希望出现这样的问题，我们可以使用浅拷贝来解决这个问题。 浅拷贝首先我们可以通过 Object.assign 来解决这个问题。 123456let a = &#123; age :1&#125;let b = Object.assign(&#123;&#125;,a)a.age = 2console.log(b.age) // 1 当然我们可以通过展开运算符(…) 来解决 123456let a = &#123; age : 1&#125;let b = &#123;...a&#125;a.age = 2console.log(b.age)// 1 通常浅拷贝就能解决大部分的问题了，但是当我们遇到如下情况就需要深拷贝 123456789let a = &#123; age : 1 job ： &#123; first : 'fa' &#125;&#125;let b = &#123;...a&#125;a.jobs.first = 'native'console.log(b.jobs.first) //native 浅拷贝只解决了第一层问题，如果接下去的值中还有对象的话，那么就要回到刚刚开始话题，我们需要深拷贝。 深拷贝这个问通常可以通过 JSON.parse(JSON.stringify(object)) 来解决。 123456789let a = &#123; age : 1 jobs : &#123; first 'fe' &#125;&#125;let b = JSON.parse(JSON.stringify(a))a.jobs.first = 'native'console.log(b.jobs.first)//fe 但是该方法是有局限性的 会忽略 undefined 不能序列化函数 不能解决循环引用的对象 1234567891011121314let obj = &#123; a : 1 b : &#123; c : 2, d : 3 &#125;&#125;obj.c = obj.bobj.e = obj.aobj.b.c = obj.cobj.b.d = obj.bobj.b.e = obj.b.clet newObj = JSON.parse(JSON.stringify(obj))console.log(new.Obj) 如果有这样一个循环引用的对象，你会发现你不能通过该方法深拷贝。 在遇到函数或者undefined 的时候该对象也不能正常的序列化 1234567let a &#123; age : undefined, jobs : function()&#123;&#125;, name : 'yf'&#125;let b = JSON.parse(JSON.stringify(a))console.log(b) // &#123;name : 'yf'&#125; 你会发现在上述的情况中，改方法会忽略掉函数 undefined 但是在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决大部分问题，并且该函数是内置函数中处理深拷贝性能最快的。当然如果你的数据中含有以上三种情况下，可以使用 lodash 的深拷贝函数。 果你所需拷贝的对象含有内置类型并且不包含函数，可以使用 MessageChannel 1234567891011121314function structuralClone(obj)&#123; return new Proise(resolve =&gt;&#123; const &#123;port1,port2&#125; = new MessageChannel(); port2.onmessage = ev =&gt; resolve(ev.data); port1.postMessage(obj); &#125;);&#125;var obj = &#123;a : 1, b : &#123; c : b&#125;&#125;// 注意该方法是异步的// 可以处理undefined 和循环引用对象const clone = await structuralClone(obj); 模块化在有Babel 的情况下 我们可以直接使用ES6模块化 1234567 //file a.js export function a()&#123;&#125; export function b()&#123;&#125; //file b.jsexport default function()&#123;&#125;import &#123;a,b&#125; from './a.js'import xx from './b.js' CommonJs 12345678910//a.jsmodule.exports = &#123; a : 1&#125;// orexports.a = 1// b.jsvar module = require('./a.js/')module.a // -&gt; log 1 在上述代码中，module.exports 和exports 很容易混淆，让我们看看大致内容的实现。. 12345678910111213141516171819var module = require('./a.js')module.a// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，// 重要的是 module 这里，module 是 Node 独有的一个变量module.exports = &#123; a: 1&#125;// 基本实现var module = &#123; exports: &#123;&#125; // exports 就是个空对象&#125;// 这个是为什么 exports 和 module.exports 用法相似的原因var exports = module.exportsvar load = function (module) &#123; // 导出的东西 var a = 1 module.exports = a return module.exports&#125;; 再来说说 module.exports 和 exports，用法其实是相似的，但是不能对 exports 直接赋值，不会有任何效果。 对于 CommonJS 和 ES6 中的模块化的两者区别是： 前者支持动态导入，也就是 require(${path}/xx.js)，后者目前不支持，但是已有提案 前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用导入会对渲染有很大影响 前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化 后者会编译成 require/exports 来执行的 AMDAMD 是由 RequireJS 提出的 1234567891011 // AMDdefine(['./a', './b'], function(a, b) &#123; a.do() b.do()&#125;)define(function(require, exports, module) &#123; var a = require('./a') a.doSomething() var b = require('./b') b.doSomething()&#125;)]]></content>
      <tags>
        <tag>es6</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的let]]></title>
    <url>%2F2018%2F08%2F12%2Flet%20%2F</url>
    <content type="text"><![CDATA[初识 let跟很多人一样，我第一次了解 let 的特性是从 MDN 的文档： 我得到的信息有这么几条： let 声明的变量的作用域是块级的； let 不能重复声明已存在的变量； let 有暂时死区，不会被提升。大部分人应该都是这么认为的，我也是这么理解的。 这个理解「没有问题」，但是不够「全面和深刻」。 第一次质疑我第一次质疑我的理解是在遇到 for 循环的时候，代码如下。 1234567// 代码段1var liList = document.querySelectorAll('li') // 共5个lifor( var i=0; i&lt;liList.length; i++)&#123; liList[i].onclick = function()&#123; console.log(i) &#125;&#125; 大家都知道依次点击 li 会打印出 5 个 5。如果把 var i 改成 let i，就会分别打印出 0、1、2、3、4： 1234567// 代码段2var liList = document.querySelectorAll('li') // 共5个lifor( let i=0; i&lt;liList.length; i++)&#123; liList[i].onclick = function()&#123; console.log(i) &#125;&#125; 然而，用我之前的知识来理解这个代码是不能自圆其说的。因为代码中依然只声明了一个 i，在 for 循环结束后，i 的值还是会变成 5 才对。 这说明我的理解有误。 于是我去看 MDN 的例子，发现鸡贼的 MDN 巧妙地避开了这个问题，它的例子是这样的： 你看 MDN 的例子，在每次循环的时候用 let j 保留的 i 的值，所以在 i 变化的时候，j 并不会变化。而console.log 的是 j，所以不会出现 5 个 5。 为什么 MDN 要故意声明一个 j 呢，为什么不直接用 i 呢？ 我猜测 MDN 为了简化知识，隐瞒了什么。 于是我去看了看 ES 文档，其中的 13.7.4.7 章节 清楚地说明了个中缘由，但是由于说得太清楚了，很多人都看不下去，不信你可以试试。 我说一下我的理解： for( let i = 0; i&lt; 5; i++) 这句话的圆括号之间，有一个隐藏的作用域 for( let i = 0; i&lt; 5; i++) { 循环体 } 在每次执行循环体之前，JS 引擎会把 i 在循环体的上下文中重新声明及初始化一次。 其他细节就不说了，太细碎了 也就是说上面的代码段2可以近似近似近似地理解为 12345678// 代码段3var liList = document.querySelectorAll('li') // 共5个lifor( let i=0; i&lt;liList.length; i++)&#123; let i = 隐藏作用域中的i // 看这里看这里看这里 liList[i].onclick = function()&#123; console.log(i) &#125;&#125; 那样的话，5 次循环，就会有 5 个不同的 i，console.log 出来的 i 当然也是不同的值。 再加上隐藏作用域里的 i，一共有 6 个 i。 这就是 MDN 加那句 let j = i 的原因：方便新人理解。 总得来说就是 let/const 在与 for 一起用时，会有一个 perIterationBindings 的概念（一种语法糖）。 从此之后，我就开始怀疑我对 let 的所有理解了。 第二次质疑我在 StackOverflow 上闲逛的时候，无意中发现了一个是关于「let 到底有没有提升」的问题： Are variables declared with let or const not hoisted in ES6? 其中一个高票回答认为 JS 中所有的声明（var/let/const/function/class），都存在提升，理由是如下代码： 12345678910111213x = "global";// function scope:(function() &#123; x; // not "global" var/let/… x;&#125;());// block scope (not for `var`s):&#123; x; // not "global" let/const/… x;&#125; 我觉得他说得挺有道理的。于是我又去 MDN 和 ECMAScript 翻了翻，发现两处疑点： MDN 关于 let 是否存在提升的章节，被编辑了两次，第一次说存在提升，第二次说不存在提升（参考 2017 年 3 月 10 号的变更记录）。也就是说 MDN 的维护者都在这个问题上产生过分歧，更何况我们了。ES 文档里出现了「var/let hoisting」字样。鉴于此，我认为应该尊重 ES 文档，认为 let 确实存在提升。只不过由于暂时死区的限制，你不能在 let x 之前使用 let。 故事并没有结束当一个疑问一直存在你脑中时，你会在潜意识中不停地对它进行消化和思考。 上面说到我认为 let 存在提升的主要原因是 ES 文档中出现了「var/let hoisting」字样。 但是我在咨询 TC39 的成员 时，他是这么说的： You’re misunderstanding the intention of that (non-normative) Note. let and const do not hoist as var and function decls do. 而且还细心地专门写了一个 gist 来详细解释（twitter 有 140 字限制）。 既然 TC39 的 representative 都说了 let hoisting 不是一个正式词汇，那我就应该重新思考一下什么是「提升」了。 于是就有了这篇文章，我想要说一下我对「提升」的理解。你看完之后，就知道 let 到底有没有「提升」。 首先明确一点：提升不是一个技术名词。要搞清楚提升的本质，需要理解 JS 变量的「创建create、初始化initialize 和赋值assign」 有的地方把创建说成是声明（declare），为了将这个概念与变量声明区别开，我故意不使用声明这个字眼。 有的地方把初始化叫做绑定（binding），但我感觉这个词不如初始化形象。 我们来看看 var 声明的「创建、初始化和赋值」过程假设有如下代码： 12345function fn()&#123; var x = 1 var y = 2&#125;fn() 在执行 fn 时，会有以下过程（不完全）： 进入 fn，为 fn 创建一个环境。 找到 fn 中所有用 var 声明的变量，在这个环境中「创建」这些变量（即 x 和 y）。 将这些变量「初始化」为 undefined。 开始执行代码 x = 1 将 x 变量「赋值」为 1 y = 2 将 y 变量「赋值」为 2也就是说 var 声明会在代码执行之前就将「创建变量，并将其初始化为 undefined」。 这就解释了为什么在 var x = 1 之前 console.log(x) 会得到 undefined。 接下来来看 function 声明的「创建、初始化和赋值」过程假设代码如下： 12345fn2()function fn2()&#123; console.log(2)&#125; JS 引擎会有一下过程： 找到所有用 function 声明的变量，在环境中「创建」这些变量。 将这些变量「初始化」并「赋值」为 function(){ console.log(2) }。 开始执行代码 fn2() 也就是说 function 声明会在代码执行之前就「创建、初始化并赋值」。 接下来看 let 声明的「创建、初始化和赋值」过程 假设代码如下： 1234&#123; let x = 1 x = 2&#125; 我们只看 {} 里面的过程： 找到所有用 let 声明的变量，在环境中「创建」这些变量开始执行代码（注意现在还没有初始化）执行 x = 1，将 x 「初始化」为 1（这并不是一次赋值，如果代码是 let x，就将 x 初始化为 undefined）执行 x = 2，对 x 进行「赋值」这就解释了为什么在 let x 之前使用 x 会报错： 12345let x = 'global'&#123; console.log(x) // Uncaught ReferenceError: x is not defined let x = 1&#125; 原因有两个 console.log(x) 中的 x 指的是下面的 x，而不是全局的 x 执行 log 时 x 还没「初始化」，所以不能使用（也就是所谓的暂时死区） 看到这里，你应该明白了 let 到底有没有提升： let 的「创建」过程被提升了，但是初始化没有提升。 var 的「创建」和「初始化」都被提升了。 function 的「创建」「初始化」和「赋值」都被提升了。 最后看 const，其实 const 和 let 只有一个区别，那就是 const 只有「创建」和「初始化」，没有「赋值」过程。 所谓暂时死区，就是不能在初始化之前，使用变量。 完了吗？故事依然没有结束，这周我在知乎上问了一个问题：如何理解 let x = x 报错之后，再次 let x 依然会报错？ 这个问题说明：如果 let x 的初始化过程失败了，那么 x 变量就将永远处于 created 状态。 你无法再次对 x 进行初始化（初始化只有一次机会，而那次机会你失败了）。 由于 x 无法被初始化，所以 x 永远处在暂时死区（也就是盗梦空间里的 limbo）！ 有人会觉得 JS 坑，怎么能出现这种情况；其实问题不大，因为此时代码已经报错了，后面的代码想执行也没机会。 文章转载于 https://www.jianshu.com/p/0f49c88cf169]]></content>
  </entry>
  <entry>
    <title><![CDATA[上下文闭包]]></title>
    <url>%2F2018%2F08%2F12%2Fwen%20bibao%2F</url>
    <content type="text"><![CDATA[执行上下文当执行js代码是产生三种上下文 全局执行上下文 函数执行上下文 eval 执行上下文 每个执行上下文中都有三个重要属性 变量对象(VO) 包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问 作用域链(js 采用词法作用域，也就是说变量的作用域是在定义时就决定了) this 12345var a = 10function foo(i)&#123; var b = 20&#125;foo() 对于上述代码，执行栈有两个上下文：全局上下文和函数foo上下文 1234stack = [ globalContext fooContext] 对于全局上下文来说 VO 大概是这样的 12345globalContext.Vo === globeglobalCOntext.Vo = &#123; a : undefined, foo : &lt;function&gt;&#125; 对于函数 foo 来说VO不能访问，只能访问到活动对象(AO) 1234567891011fooContext.VO === foo.AOfooContext.AO &#123; i : undefined, b : undefined, arguments : &lt;&gt;&#125;// arguments 是函数独有的对象（箭头函数没有）// 该对象是一个伪数组有length 属性且可以通过下标访问元素// 该对象中callee 属性代表函数本身// caller 属性代表函数的调用者 对于作用域链，可以把它理解成包含自身变量对象和上级变量对象的列表，通过 [[Scope]] 属性查找上级变量 12345678fooContext.[[Scope]] = [ globalContext.VO]fooContext.Scope = fooContext.[[Scope]] + fooContext.VOfooContext.Scope = [ fooContext.VO, globalContext.VO] 接下来我们看一个例子 12345678b() //call bconsole.log(a) //undefinedvar a = 'hello world'function b()&#123; console.log('call b')&#125; 想必以上的输出大家肯定都已经明白了，这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行上下文时，会有两个阶段。第一个阶段是创建的阶段（具体步骤是创建 VO），JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 undefined，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用。 在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升 123456789b() // call b secondfunction b()&#123; console.log('call b first')&#125;function b()&#123; console.log('call b second')&#125;var b = 'hello world' var 会产生很多错误，所以在 ES6中引入了 let。let 不能在声明前使用，但是这并不是常说的 let 不会提升，let 提升了声明但没有赋值，因为临时死区导致了并不能在声明前使用 12345var foo = 1(function foo()&#123; foo = 100 console.log(foo)&#125;()) // -&gt; f foo() &#123;foo = 10; console.log(foo)&#125; 因为js解释器在遇到非匿名的立即执行函数时，会创建一个辅助的特定对象，将函数名称作为这个对象的属性，因此函数内部才可以访问到foo 但是这个只是只读的，所以对它的赋值并不生效，所以打印的结果还是这个函数，并且外部的值也没有发生改变。 `javascriptspecialObject = {};Scope = specialObject + Scope;foo = new FunctionExpression;foo.[[Scope]] = Scope;specialObject.foo = foo;//{DontDelete},{ReadOnly} delete Scope[0];// remove specialObject from the front of scope chain]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[instanceof this]]></title>
    <url>%2F2018%2F08%2F12%2Finstanceof%20this%2F</url>
    <content type="text"><![CDATA[instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。 我们也可以试着实现一下 instanceof 12345678910111213141516function instanceof(left,right)&#123; // 获得类型的原型 let prototype = right.prototype // 获得对象原型 left = left.__proto__ // 判断对象的类型是否等于类型的原型 while(true)&#123; if(left === null)&#123; return false &#125; if(prototype === left)&#123; return true &#125; left = left.__proto__ &#125;&#125; thisthis 是很多人会混淆，但是只要记住以下规则就不难。 1234567891011121314151617181920function foo()&#123; console.log(this.a)&#125;var a = 2foo()var obj = &#123; a : 2 foo : foo&#125;obj.foo()//以上两种情况 'this' 只依赖调用函数前的对象，优先级是第二种情况大于第一种//下面写一种优先级最高的 'this' 只会绑定在'c' 上，不会被任何发那个死修改'this'的指向var c = new foo()c.a = 3console.log(c.a)//还有一种情况 利用call apply bind 改变this 优先级仅次于new 以上几种情况明白了，很多代码中的 this 应该就没什么问题了，下面让我们看看箭头函数中的 this 12345678function a()&#123; return () =&gt; &#123; return () =&gt; &#123; console.log(this) &#125; &#125;&#125;console.log(a()()()) 箭头函数其实是没有 this 的，这个函数中的 this 只取决于他外面的第一个不是箭头函数的函数的 this。在这个例子中，因为调用 a 符合前面代码中的第一个情况，所以 this 是 window。并且 this 一旦绑定了上下文，就不会被任何代码改变。]]></content>
      <tags>
        <tag>javscript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js原型]]></title>
    <url>%2F2018%2F08%2F10%2Fyuanxing%20new%2F</url>
    <content type="text"><![CDATA[原型 每个函数都有 prototype 属性，除了 Function.prototype.bind()，该属性指向原型。 每个对象都有 proto 属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 [[prototype]]，但是 [[prototype]] 是内部属性，我们并不能访问到，所以使用 proto 来访问。 对象可以通过 proto 来寻找不属于该对象的属性，proto 将对象连接起来组成了原型链。 new 新生成了一个对象 链接到原型 绑定 this 返回新对象 在调用new的过程中会发生以上四件事情，我们可以自己写一个new 123456789101112function create()&#123; //创建一个空对象 let obj = new Object() // 获得构造函数 let Con = [].shify.call(arguments) // 链接到原型 obj.__proto__ = Con.prototype // 绑定this 执行构造函数 let result = Con.apply(obj,arguments) // 确保new出来是一个新的对象 return typeof result === 'object' ? result : obj&#125; 对于实例对象来说，都是通过new产生的，无论是function Foo () 还是 let a = { b : 1}。 对于创建一个对象来说，更推荐使用字面量的方式创建对象（无论从性能上还是可读性）。 因为你使用new Object() 的方式穿件对象需要通过作用域连一层层找到Object，但是你使用字面量就没有这个问题。 12345function Foo() &#123;&#125;// function 就是个语法堂// 内部等同于 new Function()let a = &#123; b: 1 &#125;// 这个字面量内部也是使用了 new Object() 对于new来说还需要注意运算的优先级 123456789101112function Foo()&#123; return this;&#125;Foo.getName = function()&#123; console.log('1');&#125;Foo.prototype.getName = function()&#123; console.log('2')&#125;new Foo.getName();// --&gt; 1new Foo().getName();// --&gt;2 从上图可以看出，new Foo() 的优先级大于 new Foo ，所以对于上述代码来说可以这样划分执行顺序。 12new (Foo.getName());(newFoo()).getName() 对于第一个函数来说，先执行了 Foo.getName() ，所以结果为 1；对于后者来说，先执行 new Foo() 产生了一个实例，然后通过原型链找到了 Foo 上的 getName 函数，所以结果为 2]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的类型转换]]></title>
    <url>%2F2018%2F08%2F10%2Flei%20change%2F</url>
    <content type="text"><![CDATA[类型转换##转Boolean 在条件判断时，除了 undefined, null, false, NaN, ‘’, 0, -0, 在其他所有值都转化为true, 包括所有对象。 对象转基本类型对象在转换基本类型时，首先会调用 valueOf 然后调用 toString。并且这两个方法你是可以重写的。 12345let a = &#123; valueOf()&#123; return 0 &#125;&#125; 当然你也可以重写 Symbol.toPrimitive, 该方法在转基本类型的时调用优先级最高。 12345678910111213let a = &#123; valueOf()&#123; return 0； &#125;， toString()&#123; return '1'; &#125;, [Symbol.toPrimitive]()&#123; return 2; &#125;&#125;1 + a // =&gt;3'1' + a // =&gt; '12' 四则运算符只有当加法运算时，其中一个为字符串类型就会把另一个转为字符串类型，其他运算只有其中有个数，那么另一个就会转为数字。并且揭发运算会触发是那种类型： 将值转为原始值，转为数字，转为字符串。 1234561 + '1' // '11'2 * '2' // 4[1,2] + [2,1] // '1,22,1'// [1, 2].toString() -&gt; '1,2'// [2, 1].toString() -&gt; '2,1'// '1,2' + '2,1' = '1,22,1' 对于加号 需特别注意这个表达式 ‘a’ ++ ‘b’ 123'a' + + 'b' //-&gt;'aNaN'// 因为 + 'b' -&gt;NaN// 你可能看到 + '1' -&gt;1 操作符 上图中的 toPrimitive 就是对象转基本类型 这里解析一道题目 [] == ![] -&gt;true 下面为解释 1234567891011// [] 转换成true 然后取反 false[] == false// 根据第8条可以得出[] == ToNumber(false)[] ==0// 根据第10条得ToPrimitive([]) == 0//[].toString() -&gt; '''' == 0// 根据第6条0 == 0 // -&gt;true 比较运算符 如果是对象，就通过 toPrimitive 转换对象 如果是字符串，就通过Unicode 字符索引来比较]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的内置类型]]></title>
    <url>%2F2018%2F08%2F10%2Fjs%20Built-in%20type%2F</url>
    <content type="text"><![CDATA[内置类型js中分为七种内置类型，七种内置类型分为两大类型： 基本类型和对象。 基本类型有六种：null, undefined, boolean, number,string, symbol. 其中就是其中 JS 的数字类型是浮点类型的，没有整型。并且浮点类型基于 IEEE 754标准实现，在使用中会遇到某些 Bug。 NaN 也属于Number类型并且NaN不等于自身。 对于基本类型来说，如果使用字面量的方式，那么这个变量只是个字面量，只有在必要的时候才会转换为对应的类型 12let a = 11//这只是字面量，不是number类型。a.toString()// 使用时才会转化问对象类型。 对象（Object）是引用类型，在使用过程中会遇到深浅拷贝的问题。 1234let a = &#123;name : 'ga'&#125;let b = a;b.name = 'ag';console.log(a.name)// ag Typeoftypeof 对于基本类型除了null都可以显示正确的类型 123456typeof 1// 'number'typeof '1' // 'string'typeof undefined // 'undefinedtypeof true // 'boolean'typeof Symbol() // 'symbol'typeof b // b 没有声明会显示undefined typeof 对于对象，除了函数都会显示Object 123typeof [] // 'object'typeof &#123;&#125; // 'object'typeof console.log // 'function' 对于null来说，虽然它是基本类型但是会显示object，这是存在很久bug1typeof null //'object' 为什么会这样呢，从网下查整理如下：为在 JS 的最初版本中，使用的是 32 位系统，为了性能考虑使用低位存储了变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。 如果我们想获得一个变量的正确类型，可以通过 Object.prototype.toString.call(xx)。这样我们就可以获得类似 [Object Type] 的字符串。 12345678910let a // 我们也可以这样判断undefineda === undefined// 但是undefined 不是保留字，能在低版本浏览器被赋值let undefined = 1//这样判断就会出错// 所以用下面方法 且代码少// 因为void 后边随便跟上一个组成表达式// 返回就是 undefineda === void 0]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的事件冒泡捕获委托]]></title>
    <url>%2F2018%2F08%2F08%2Fbubbleevent%2F</url>
    <content type="text"><![CDATA[事件冒泡123456789101112131415161718192021222324252627.wrapper&#123; width: 300px; height: 300px; background：red;&#125;.content&#123; width: 200px; heightt: 200px; background: green;&#125;.box&#123; width: 100px; height: 100px; background: yellow;&#125;&lt;div class= "wrapper"&gt; &lt;div class="content"&gt; &lt;div class= "box"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;var wrapper = document.getElementByTagName('div')[0];var content = document.getElementByTagName('div')[0];var box = document.getElementByTagName('div')[0];wrapper.addEventListener('click',function(consoe=le,log('wrapper')&#123;&#125;,false));content.addEventListener('click',function(consoe=le,log('content')&#123;&#125;,false));box.addEventListener('click',function(consoe=le,log('box')&#123;&#125;,false)); 特别的是，当我们点击box的时候会把三个事件都触发了，点击content的时候，会把content和wrapper都触发。这就叫事件冒泡 事件冒泡：结构上的而非视觉上的嵌套关系的元素，会存在事件冒泡的功能，即同一事件，自子元素冒泡向父元素。（自底向上），如题，点击box子元素的时候，它会一级一级的冒向父元素，自地上向，最后冒向wrapper，结构上的，而非视觉上的。事件冒泡是存在于结构逻辑上的，并不是视觉逻辑上的。 事件捕获（只有谷歌有）声明：一个对象的一个时间类型，只能存在一个时间类型。将冒泡转为捕获很简单，只要false转为 true就ok。 时间捕获：结构上嵌套关心的元素，会在时间捕获的功能，即同一事件，自父元素捕获至子元素（时间源元素）。 从以上例子来看，点击box会先打印wrapper然后是content最后box。 IE没有捕获最新版本火狐和Opera有。 注意同一个对象的同一个事件类型绑定了两个函数，让两个函数分别遵循事件捕获和事件冒泡，它们会先捕获然后先冒泡将以上代码复制一次，点击box。 捕获—&gt;捕获—&gt;事件执行—&gt;冒泡—&gt;冒泡—&gt;事件执行。 另外有些事件 冒泡功能，如：focus，blur等。 取消冒泡和阻止默认事件事件对象，在每个事件处理函数，可以填一个形参e，系统会自动往里面传一个东西，叫做事件对象。e 上面有很多属性，记录很多事件发生时关键性数据，如鼠标坐标，事件类型等 事件对象上面有一个方法可以阻止冒泡事件。 1event.stopPropagetion(); 但不支持IE9以下。IE能用的： e.cancelBubble = true; 现在我们来封装一个方法来兼容各种浏览器，用于阻止默认事件。 1234567function stopBubble(event)&#123; if(event.stopPropagetion)&#123; event.stopPropagetion(); &#125;else&#123; event.cancelBubble = true; &#125;&#125; 阻止默认事件默认事件，即是浏览器默认在一定情况下会自动触发的事件，例如鼠标右击产生菜单，如果我们不需要就可以阻止默认事件。 return false 方式；只有绑定事件的时候，才能有这种取消。 attachEvent 不能用，需要以下方法 123document.contextmenu = function()&#123; return false;&#125; event.preventDefault() W3cn标准，IE9以下不兼容。 123document.oncontextmenu = function(e)&#123; e.preventDefault();&#125; 兼容IE， event.returnValue = false; 123document.oncontextmenu = function(e)&#123; e.returnValue = false;&#125; 再来一个兼容性的方法来取消默认事件。 1234567function cancelHandler(event)&#123; if(event.preventDefault)&#123; event.preventDefault(); &#125;else&#123; event.returnValue = false; &#125;&#125; a标签作为按钮是，要取消它的默认事件。 123a.onclick = function()&#123; return false;&#125; 事件对象（IE浏览器）在IE中事件对象会存在window上面，需要兼容如下。 123div.onclick = function(e)&#123; e = window.event || e;&#125; 事件源对象，事件对象上面有一个属性会记录事件源对象，用来记录究竟是谁触发这事件。 火狐： event.target;IE： event.srcElement;谷歌以上都有 事件委托背景： 一个ul里边有个很多个里，点击一个li，输出对应的内容，后期还会继续添加。 利用事件源对象进行编程。ul的区域大小，是由李决定的，当我们点击第一个li，就会冒泡给ul。我们绑定ul就ok。 123456var ul = document.getElemntsByTagName('ul')[0];ul.onclick = function(e)&#123; var event = e || window.event; var target = event.target || event.srcElement; console.log(target.innerText);&#125; 优点： 性能 不需要循环所有的元素一个个绑定事件。 灵活 当有新的子元素时不需要重新绑定事件。]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js时间线]]></title>
    <url>%2F2018%2F08%2F08%2Ftime-line%2F</url>
    <content type="text"><![CDATA[JavaScript 加载时间线 js时间线是js加载从开始到结束的过程，其执行顺序有助于我们优化代码，提高运行速度。 1、创建Document对象，开始解析web页面。解析HTML元素和他们的文本内容后添加Element对象和Text节点到文档中。这个阶段document.readyState 是loading。（状态位） 2、遇到link外部css，创建线程加载，并继续解析文档 3、遇到img等，先正常解析dom结构，然后浏览器异步加载src，并继续解析文档。（先解析完，后加载完） 4、遇到外部js，并且设置async，defer浏览器加载，浏览器创建线程加载，并继续解析文档。对于async属性的脚本，脚本加载完成后立即执行。 5、遇到script外部js，并且没有设置async、defer，浏览器加载，并阻塞，等待js加载完成并执行该脚本，然后继续解析文档。 6、当文档解析完成，document.readyState = ‘interactive’（活跃，越来状态是loading，告诉我们已成型，可以修改）。（DOM树刚刚解析完毕） 7、文档解析完成后，所有设置有defer的脚本会按照顺序执行。（注意与async的不同,但同样禁止使用document.write()）; 8、文档解析完毕后，document对象触发DOMContentLoaded事件（系统的方式，没有句柄方式，只用addEventListener能绑定这个事件。），这也标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段（事件监听机制，DOM树解析完成就可以相应事件了）。 9、当所有async的脚本加载完成并执行后、img等加载完成后，document.readyState = ‘complete’，window对象触发load事件。 10、从此，以异步响应方式处理用户输入、网络事件等。 要注意的是，任何情况都禁止使用document.write()，因为它能够清除文档流（如果文档流没有加载完毕，不会清楚，而是跟着加载了的文档后面），所有标签都清除。 12345678&lt;div&gt;&lt;/div&gt;&lt;script&gt; console.log(doucment.readyState);//loading&lt;/script&gt;&lt;span&gt;&lt;/span&gt;&lt;script&gt; conosle.log(doucment.readyState);//loading script 也是标签，这里不是interactive&lt;/script&gt; DOMContentLoaded它是系统上的事件，只有addEventListener才能绑定这个事件。这个事件跟window.onload事件是一样的感觉。利用它我们可以操作一些解析完就执行的操作。比window.onload更快，因为肯定是解析完毕比加载完毕更快。]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 正则表达式]]></title>
    <url>%2F2018%2F08%2F07%2Fblog%2F</url>
    <content type="text"><![CDATA[正则表达式 正则表达式，人为设定的一种方法，用来处理字符串的，匹配某种特定的字符串。正则表达式，代表一定的规则。 知识点 正则表达式的作用： 匹配特殊原则的字符的最佳选择。它也是对象 正则表达式的创建方法如下：1234var reg = new RegExp("abc");var reg1 = new /abc/ (字面量形式)；var reg2 - new RegExp(reg)l; //就相当于重新写一个与reg一样的，但是你改，我不改。var reg = RegExp(reh); //这个写法就是像直接引用。这个是跟随改变，他改我就改。 但是如果使用new的形式进行创建，第一个参数写的是正则，第二个参数表示属性(g,m,i).通常都使用第二种方法。采用字面量的形式。 属性i: ignore; 忽略。如果在正则表达式写i属性，表示忽略大小写 12345var reg = /abc/;var reg1 = /abc/i;var str - "ABC";reg.test(str); //falsereg1.test(str); //true g:global;全局；匹配到一个之后，会继续匹配，返回一个类数组。 123var reg = /abc/g;var str = "abcajciaccd";str.match(reg); //[abc,abc] m:mutiple; 多行匹配；针对多行，行首识别。 12345var reg = /^ab/;var reg1 - /^ab/m;var str = "acabcaca\ahnacha";str.match(reg); //[abacss]; 换行之后就不再匹配；注意，g也识别不了换行str.match (reg1); //[absad,hahchh]、换行之后继续匹配。 表达式表达式，定义匹配规则。一个表达式只能匹配一位。/[abc][cd]/:第一位匹配abc任意一位，第二位匹配cd任意一位。方括号里边表示区间。 123var reg = /[abc][cde][xyz]/;var str = 'qwefwfew';str.match(reg) //["acy"]; 字符类 字符 匹配 […] 方括号内的任意字符 [^…] 不在方括号内的任意字符 . 除换行符合其他Unicode行终止符之外的任意字符 \w 任意ASCII字符组成的单词，等价于[a-z A-Z 0-9] \W 任何非ASCII字符组成的单词，等价于[^a-z A-Z 0-9] \s 任何Unicode空白符 \S 任何非Unicode空白符 \d 任何ASCII数字，等价于[0-9] \D 非ASCII数字，等价于[^0-9] \b 退格直接量(特例) 重复 字符 含义 {n,m} 匹配前一项至少n次但不超过m次 {n,} 匹配前一项n次或者更多次 ? 匹配前一项0次或1次，也就是说前一项是可以选的，等价于{0,1} + 匹配前一项一次或多次等价于{1,} * 等价于{0,} 非贪婪的重复：上边的重复匹配自读是尽可能多的匹配字符，这种成为贪婪重复，如果需要尽可能少的匹配，这种称为非贪婪的重复，只需要在待匹配的字符后面加一个?即可。有时候会有一些与期望不同的情况，所以在实际使用的时候要注意正则匹配的原理，它是从开头进行匹配不会跳跃。 选择、分组和引用 字符 含义 丨 选择，匹配的是该符号左边的字表达式或右边的子表达式 (…) 组合将集合项合并成一个单元，可用过’*’ ‘+’ ‘?’ ‘丨’等符号加以修饰，而且可以记住这个匹配的字符，供后面的引用和使用 (?….) 只组合，与上面的基本相同，唯一的区别就是不会记忆匹配字符，后面无法引用。 \n 引用，和前边的(…)一起使用，找和第n和括号匹配的记忆字符，注意第几个的时候以左括号为基准 指定匹配位置 字符 含义 ^ 匹配字符串开头 $ 匹配字符串结尾 \b 匹配一个单词的边界 \B 匹配非单词边界的位置 (?=p) 零宽正向先行判断，要求接下来的字符都与p匹配，但不能包括匹配p的那些字符（匹配结果不包括p） (?!p) 零宽负向现行判断，要求接下来的字符不与p匹配 修饰符 字符 含义 i 执行不区分大小写的匹配 g 执行一个全局匹配 m 多行匹配 用于匹配string方法 searchh()参数为正则表达式，返回匹配成功的字符串的其实位置，否则返回-1，不支持g，默认忽略。 replace() 有两个参数，第一个为匹配正则表达式，第二个为要替换成的字符串，可以为’$’ +数字，与正则表达式中的引用相同，只不过这里用’&amp;’ 而不是’\’，第二个参数也可以是一个函数，必须有一个返回值，返回值为替换的值，这个函数的参数为匹配成功的字符串。 match() 返回值为一个数组，其中，当参数正则表达式执行的不是全局检索(g)是，第一个元素为匹配的字符串，其余元素为正则表达式中括号匹配的子表达式，且只返回第一个匹配成功的；否则，会返回所有满足正则表达式的元素构成的数组，不返回括号中的子表达式。 split() 该方法吧字符串按照参数拆分成数组，参数可以为正则表达式。 RegExp对象 属性global：是否有g 属性； ignoreCase ：是否有i属性 multiline；是否有m属性； lastIndex:最后匹配的字符位置（注意，在一写匹配的时候需要重置） source： 对应正则表达式的源文本 方法exec() 返回值为一个数组，第一个元素为匹配的字符串，其余元素为正则表达式中括号匹配的子表达式，且返回第一个匹配成功的，返回值有index(发生匹配的位置) 和input(正在检索的字符串)属性，当同一个正则表达式再次调用时，会从，lastIndex继续检索，返回值相同，当没有匹配结果的时候，lastIndex重置为0 test()判断时匹配，成功返回true，失败为false。]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[link 与 @import 的区别]]></title>
    <url>%2F2018%2F08%2F07%2Fjsd%2F</url>
    <content type="text"><![CDATA[两种方式都是为了CSS文件的加载，但是还存在细微的差别。 link数据XHTML标签，而@import完全是CSS提供的一种方式。link标签除了可以加载CSS外，还可以做很多其他的事情，例如定义RSS，定义rel连接属性。而@import就只能加载CSS。 加载顺序的差别。当一个页面被加载的时候（或者被浏览器浏览的时候），link引用的CSS会被同时加载，而@import引用的CSS会等页面全部加载才会被加载。 兼容性差别。由于@import是CSS2.1提出的所以旧版本浏览器不支持，@import只有在IE5以上可以用，link无此问题。 使用dom控制样式时的差别。当使用javascript控制dom去改变样式时，只能使用link，而dom不可以控制@import。]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
